#!/usr/bin/perl -Tw

# CLog - Commandline logbook for amateur radio
#
# Copyright (C) 2008-2015 Ernest Neijenhuis PA3HCM
#
# This file is part of CLog.
#
# CLog is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CLog is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CLog.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use Switch;
use DBI;
use POSIX qw(:math_h);

# Constants
use constant VERSION => '1.1';
use constant DBVERSION => '1.1';
use constant PI => 3.14159265358979;


# Default settings
my %config = (
	dbhost => 'localhost',
	dbname => 'clog',
	dbuser => 'cloguser',
	dbpass => 'clogpass',
	default_freq => '',
	default_mode => '',
	default_rst_rx => '',
	default_rst_tx => '',
	statistics_modes => 'CW,SSB,FM,ALL',
	statistics_bands => '160m,80m,40m,30m,20m,17m,15m,12m,10m,2m,70cm,23cm,3cm',
	mycall => '',
	mylocator => '',
	list_columns => 'callsign qso_date qso_time band mode rst_tx rst_rx comments',
	columns => '80',
	export_html_columns => 'callsign qso_date qso_time band mode rst_tx rst_rx comments',
	export_cabrillo_columns => 'qso_date qso_time freq mode mycall rst_tx data_tx callsign rst_rx data_rx',
);


# -------------------------------------------------------------------------
# FUNCTIONS
# -------------------------------------------------------------------------

# Read and parse the configuration file
sub read_configfile {
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $configfile = $ENV{'HOME'} . '/.clogrc';
	if (defined($ENV{'CLOGRC'})) {
		if ($ENV{'CLOGRC'} =~ /.*\/.*/) {
			$configfile = $ENV{'CLOGRC'};
		} else {
			$configfile = $ENV{'HOME'} . '/' . $ENV{'CLOGRC'};
		}
	}
	if (-e $configfile) {
		if (-r $configfile) {
			open (CONFIG, "<$configfile");
			while (<CONFIG>) {
				chomp;
				s/#.*//;
				s/^\s+//;
				s/\s+$//;
				next unless length;
				my ($var, $value) = split(/\s*=\s*/, $_, 2);
				if ($var eq 'default_mode') { $value = uc($value); }
				switch ($var) {
					case [ 'dbhost',
						'dbname',
						'dbuser',
						'dbpass',
						'default_rst_rx',
						'default_rst_tx',
						'default_mode',
						'default_freq',
						'statistics_modes',
						'statistics_bands',
						'mycall',
						'mylocator',
						'list_columns',
						'columns',
						'export_html_columns',
						'export_cabrillo_columns'
					] {
						$config{$var} = $value;
					}
				}
			}
			$config{'mycall'} = uc($config{'mycall'});
			close $configfile;
		} else {
			print STDERR "WARNING: unable to read $configfile, using defaults\n";
		}
	}
	return %config;
}

# This function prints the standard help text.
sub syntax {
	print "CLog " . VERSION . " - Copyright (c) 2008-2015, Ernest Neijenhuis PA3HCM\n";
	print "\n";
	print "Syntax:\n";
	print "  clog                             Display this help text\n";
	print "  clog ad[d] <arg> [<arg> [..]]    Add entry to logbook\n";
	print "  clog up[date] <id> <arg> [<arg> [..]] Update entry in logbook\n";
	print "  clog de[lete] <id>               Delete entry from logbook\n";
	print "  clog li[st] [<id>]               List all logbook entries, or just <id>\n";
	print "  clog lo[cator] <locator>         Show bearing and distance for locator\n";
	print "  clog sh[ow] <id>                 Show details for given entry\n";
	print "  clog st[atistics] <id>           Display logbook totals\n";
	print "  clog export_adif                 Export logbook in ADIF v1 format\n";
	print "  clog export_cab2                 Export logbook in Cabrillo v2.0 format\n";
	print "  clog export_cab3                 Export logbook in Cabrillo v3.0 format\n";
	print "  clog export_csv                  Export logbook in CSV format\n";
	print "  clog export_html                 Export logbook in an HTML formatted table\n";
	print "  clog import_cty <file>           Import countries/prefixes from cty.dat file\n";
	print "  clog dx[cc] <call|prefix>        Search the imported cty.dat\n";
	print "  clog qs[l] tx|rx <id>            Set QSL sent/received for given entry\n";
	print "\n";
	print "CLog tries to recognize arguments in the following way:\n" ;
	print "- Frequency always ends with a 'K' (kHz) or 'M' (MHz), decimals are allowed.\n";
	print "- Reports start with a 't' or 'T' (transmitted), or 'r'/'R' (received)\n";
	print "- Known modes: SSB LSB USB CW RTTY (AM)TOR PKT AM FM SSTV ATV PAC(TOR) CLO(VER)\n";
	print "- Date/time formats: yyyy-mm-dd hh:mm (in UTC/GMT)\n";
	print "- Locator: loc=ccnn loc=ccnncc loc=ccnnccnn\n";
	print "- Contest exchanges: txs=nnn rxs=nnn txd=ccc rxd=ccc\n";
	print "- Force callsign field: call=ccnncc\n";
	print "\n";
	print "Some values can be set to a default value, using ~/.clogrc, see documentation.\n";
	print "The <id> field is just a unique number, and doesn't say anything about the\n";
	print "number of QSO's in the database. Read the clog(1) man page for more help.\n";
	return 0;
}

# This function tries to recognize the given string. It returns
# the recognized type (e.g. call, frequency, date) or 'unknown'
# when not recognized.
sub get_type {
	my $arg = shift;
	my $type = "unknown";
	switch ($arg) {
		# Locator
		case /^[Ll][Oo][Cc]=[A-Za-z]{2}[0-9]{2}$/ {
			$type = "is_locator";
		}
		case /^[Ll][Oo][Cc]=[A-Za-z]{2}[0-9]{2}[A-Za-z]{2}$/ {
			$type = "is_locator";
		}
		case /^[Ll][Oo][Cc]=[A-Za-z]{2}[0-9]{2}[A-Za-z]{2}[0-9]{2}$/ {
			$type = "is_locator";
		}

		# Received serial# (contests)
		case /^[Rr][Xx][Ss]=\d+$/ {
			$type = "is_serial_rx";
		}

		# Sent serial# (contests)
		case /^[Tt][Xx][Ss]=\d+$/ {
			$type = "is_serial_tx";
		}

		# Received data (contests)
		case /^[Rr][Xx][Dd]=.*$/ {
			$type = "is_data_rx";
		}

		# Sent data (contests)
		case /^[Tt][Xx][Dd]=.*$/ {
			$type = "is_data_tx";
		}

		# RST-rx
		case /^[Rr]\d\d+$/ {
			$type = "is_rst_rx";
		}
		case /^[Rr]\d\d+[A|a|\+]$/ {
			$type = "is_rst_rx";
		}
		case /^[Rr]\d\d+[A|a|\+]\d+$/ {
			$type = "is_rst_rx";
		}
		case /^[Rr]\d\d+[A|a|\+]\d+[Dd][Bb]$/ {
			$type = "is_rst_rx";
		}

		# RST-tx
		case /^[Tt]\d\d+$/ {
			$type = "is_rst_tx";
		}
		case /^[Tt]\d\d+[A|a|\+]$/ {
			$type = "is_rst_tx";
		}
		case /^[Tt]\d\d+[A|a|\+]\d+$/ {
			$type = "is_rst_tx";
		}
		case /^[Tt]\d\d+[A|a|\+]\d+[Dd][Bb]$/ {
			$type = "is_rst_tx";
		}

		# Callsign
		case /^[A-Za-z0-9]{1,3}\/[A-Za-z0-9]{3,12}\/[A-Za-z0-9]{1,3}$/ {
			$type = "is_callsign";
		}
		case /^[A-Za-z0-9]{1,3}\/[A-Za-z0-9]{3,12}$/ {
			$type = "is_callsign";
		}
		case /^[A-Za-z0-9]{3,12}\/[A-Za-z0-9]{1,3}$/ {
			$type = "is_callsign";
		}
		case /^[A-Za-z]{1,3}\d{1,2}[A-Za-z]{1,12}/ {
			$type = "is_callsign";
		}
		case /^\d{1,2}[A-Za-z]{1,3}\d{1,2}[A-Za-z]{1,12}\/{0,1}[A-Za-z0-9]{0,3}/ {
			$type = "is_callsign";
		}
		case /^[Cc][Aa][Ll][Ll]=.*$/ {
			$type = "is_callsign";
		}

		# Date
		case /^\d{4}-\d{2}-\d{2}$/ {
			$type = "is_date";
		}

		# Time
		case /^\d{1,2}:\d{2}$/ {
			$type = "is_time";
		}

		# Frequency
		case /^\d{2,12}[KkMm]$/ {
			$type = "is_freq";
		}
		case /^\d{0,6}\.\d{1,6}[KkMm]$/ {
			$type = "is_freq";
		}

		# Mode
		case /^[AaFf][Mm]$/ {
			$type = "is_mode";
		}
		case /^[Cc][Ww]$/ {
			$type = "is_mode";
		}
		case /^[LlUuSs][Ss][Bb]$/ {
			$type = "is_mode";
		}
		case /^[Rr][Tt]{2,2}[Yy]$/ {
			$type = "is_mode";
		}
		case /^[Tt][Oo][Rr]$/ {
			$type = "is_mode";
		}
		case /^[Aa][Mm][Tt][Oo][Rr]$/ {
			$type = "is_mode";
		}
		case /^[Pp][Kk][Tt]$/ {
			$type = "is_mode";
		}
		case /^[Aa][Tt][Vv]$/ {
			$type = "is_mode";
		}
		case /^[Pp][Aa][Cc]$/ {
			$type = "is_mode";
		}
		case /^[Pp][Aa][Cc][Tt][Oo][Rr]$/ {
			$type = "is_mode";
		}
		case /^[Cc][Ll][Oo]$/ {
			$type = "is_mode";
		}
		case /^[Cc][Ll][Oo][Vv][Ee][Rr]$/ {
			$type = "is_mode";
		}

		else {
			$type = "unknown";
		}
	}
	return ($type);
}

# Lists all entries, or just the record with the given ID. The output
# fits on a 80-character display, so some fields are shortened.
sub list_log {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $search_id = shift;
	my $query = '';
	my $band = '';
	my $column = '';
	my $sth;
	if ($search_id == 0) {
		$query = 'SELECT id, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments, qsl_tx, qsl_rx FROM qsos WHERE mycall=? ORDER BY qso_date, qso_time, id;';
		$sth = $dbh->prepare($query);
		$sth->execute($config{'mycall'});
	} else {
		$query = 'SELECT id, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments, qsl_tx, qsl_rx FROM qsos WHERE id=? AND mycall=?;';
		$sth = $dbh->prepare($query);
		$sth->execute($search_id, $config{'mycall'});
	}
	my ($id, $callsign, $qso_date, $qso_time, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $comments, $qsl_tx, $qsl_rx);
	$sth->bind_columns(\$id, \$callsign, \$qso_date, \$qso_time, \$freq, \$mode, \$rst_tx, \$rst_rx, \$locator, \$serial_tx, \$serial_rx, \$data_tx, \$data_rx, \$comments, \$qsl_tx, \$qsl_rx);
	my $header= "ID---";
	foreach $column (split / /, $config{'list_columns'}) {
		switch ($column) {
			case 'callsign' {
				$header .= " Callsign----";
			}
			case 'qso_date' {
				$header .= " Date--";
			}
			case 'qso_time' {
				$header .= " UTC-";
			}
			case 'band' {
				$header .= " Band-";
			}
			case 'freq' {
				$header .= " MHz------";
			}
			case 'mode' {
				$header .= " Mode";
			}
			case 'rst_tx' {
				$header .= " TX-";
			}
			case 'rst_rx' {
				$header .= " RX-";
			}
			case 'locator' {
				$header .= " Loc---";
			}
			case 'bearing' {
				$header .= " Deg";
			}
			case 'distance' {
				$header .= " KM---";
			}
			case 'serial_tx' {
				$header .= " TX#--";
			}
			case 'serial_rx' {
				$header .= " RX#--";
			}
			case 'data_tx' {
				$header .= " TXd--";
			}
			case 'data_rx' {
				$header .= " RXd--";
			}
			case 'comments' {
				$header .= " Comments-----------------------------------------";
			}
			case 'dxcc' {
				$header .= " DXC";
			}
			case 'qsl' {
				$header .= " QSL";
			}
		}
	}
	print substr($header, 0, $config{'columns'}) . "\n";
	my $line;
	my $bearing;
	my $distance;
	while($sth->fetch()) {
		$line = sprintf ('%5s', $id);
		foreach $column (split / /, $config{'list_columns'}) {
			switch ($column) {
				case 'callsign' {
					$line .= sprintf (' %-12s', $callsign);
				}
				case 'qso_date' {
					$line .= sprintf (' %6s', substr ($qso_date, 2, 2) . substr($qso_date, 5, 2) . substr($qso_date, 8, 2));
				}
				case 'qso_time' {
					$line .= sprintf (' %4s', substr ($qso_time, 0, 2) . substr($qso_time, 3, 2));
				}
				case 'freq' {
					$line .= sprintf (' %9.3f', $freq);
				}
				case 'band' {
					$line .= sprintf (' %5s', substr (mhz_to_band($freq), 0, 5));
				}
				case 'mode' {
					$line .= sprintf (' %-4s', $mode);
				}
				case 'rst_tx' {
					$line .= sprintf (' %-3s', $rst_tx);
				}
				case 'rst_rx' {
					$line .= sprintf (' %-3s', $rst_rx);
				}
				case 'locator' {
					$line .= sprintf (' %6s', $locator);
				}
				case 'bearing' {
					if (($locator ne '') && ($config{'mylocator'} ne '')) {
						($bearing, $distance) = beardist(qratoll($config{'mylocator'}), qratoll($locator));
						$line .= sprintf (' %3.0f', $bearing);
					} else {
						$line .= '    ';
					}
				}
				case 'distance' {
					if (($locator ne '') && ($config{'mylocator'} ne '')) {
						($bearing, $distance) = beardist(qratoll($config{'mylocator'}), qratoll($locator));
						$line .= sprintf (' %5.0f', $distance);
					} else {
						$line .= '      ';
					}
				}
				case 'serial_tx' {
					$line .= sprintf (' %5s', $serial_tx);
				}
				case 'serial_rx' {
					$line .= sprintf (' %5s', $serial_rx);
				}
				case 'data_tx' {
					$line .= sprintf (' %5s', $data_tx);
				}
				case 'data_rx' {
					$line .= sprintf (' %5s', $data_rx);
				}
				case 'comments' {
					$comments =~ s/\n/ /g;
					$comments =~ s/\r/ /g;
					$line .= sprintf (' %-50s', substr ($comments, 0, 28));
				}
				case 'dxcc' {
					$line .= sprintf (' %-3s', callsign_to_dxcc($dbh, $callsign));
				}
				case 'qsl' {
					if ($qsl_tx eq 'Y') {
						$line .= ' S/';
					} else {
						$line .= ' -/';
					}
					if ($qsl_rx eq 'Y') {
						$line .= 'R';
					} else {
						$line .= '-';
					}
				}
			}
		}
		print substr($line, 0, $config{'columns'}) . "\n";
	}
$sth->finish();
}


# This function displays the full record in a nicely formatted way.
sub show_entry {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $search_id = shift;
	my $dxcc = '';
	my $country = '';
	my $qsl_sent = '';
	my $qsl_rcvd = '';
	my $query = 'SELECT id, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments, qsl_tx, qsl_rx FROM qsos WHERE id=? AND mycall=?;';
	my $sth = $dbh->prepare($query);
	$sth->execute($search_id, $config{'mycall'});
	my ($id, $callsign, $qso_date, $qso_time, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $comments, $qsl_tx, $qsl_rx);
	$sth->bind_columns(\$id, \$callsign, \$qso_date, \$qso_time, \$freq, \$mode, \$rst_tx, \$rst_rx, \$locator, \$serial_tx, \$serial_rx, \$data_tx, \$data_rx, \$comments, \$qsl_tx, \$qsl_rx);
	while($sth->fetch()) {
		print "ID       : $id\n";
		print "Callsign : $callsign";
		$dxcc = callsign_to_dxcc($dbh, $callsign);
		$country = dxcc_to_country($dbh, $dxcc);
		unless ($country eq '') {
			print " ($dxcc - $country)\n";
		} else {
			print "\n";
		}
		print "Date     : $qso_date\n";
		print "Time     : $qso_time UTC\n";
		print "Frequency: $freq MHz\n";
		print "Mode     : $mode\n";
		print "RST tx   : $rst_tx\n";
		print "RST rx   : $rst_rx\n";
		if (($locator ne '') && ($config{'mylocator'} ne '')) {
			my ($bearing, $distance) = beardist(qratoll($config{'mylocator'}), qratoll($locator));
			$bearing = int($bearing);
			$distance = int($distance);
			print "Locator  : $locator ($distance km, $bearing degrees)\n";
		} else {
			print "Locator  : -\n";
		}
		if ($serial_tx == 0) { $serial_tx = "-"; }
		if ($serial_rx == 0) { $serial_rx = "-"; }
		if ($data_tx eq '') { $data_tx = "-"; }
		if ($data_rx eq '') { $data_rx = "-"; }
		print "Sent     : $serial_tx / $data_tx\n";
		print "Received : $serial_rx / $data_rx\n";
		$comments =~ s/\n/ /g;
		$comments =~ s/\r/ /g;
		print "Comments : $comments\n";
		if ($qsl_tx eq 'Y') { $qsl_sent = "sent" } else { $qsl_sent = "not sent"; }
		if ($qsl_rx eq 'Y') { $qsl_rcvd = "received" } else { $qsl_rcvd = "not received"; }
		print "QSL      : $qsl_sent, $qsl_rcvd\n"
		
	}
}

# Used to add an entry to the logbook.
sub add_entry {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my @args = @ARGV;
	shift(@args);
	my $callsign = '';
	my $rst_rx = '';
	my $rst_tx = '';
	my $locator = '';
	my $serial_tx = '';
	my $serial_rx = '';
	my $data_tx = '';
	my $data_rx = '';
	my $freq = '';
	my $mode = '';
	my $qso_date = '';
	my $qso_time = '';
	my $comments = '';
	my $rest_is_comments = 0;

	# Parse the given arguments
	foreach my $arg (@args) {
		my $type = get_type($arg);
		if (($rest_is_comments == 0) && ($type ne 'unknown')) {
			switch ($type) {
				case 'is_callsign' {
					if ($callsign eq '') {
						$callsign = uc($arg);
						$callsign =~ s/CALL=//i;
					}
				}
				case 'is_freq' {
					if ($freq eq '') {
						$freq = uc($arg);
						if (substr($freq, -1, 1) eq 'K') {
							$freq =~ s/K//;
							$freq = $freq / 1000;
						} else {
							$freq =~ s/M//;
						}
					}
				}
				case 'is_mode' {
					if ($mode eq '') {
						$mode = uc($arg);
					}
				}
				case 'is_rst_tx' {
					if ($rst_tx eq '') {
						$rst_tx = uc($arg);
						$rst_tx =~ s/^T//;
					}
				}
				case 'is_rst_rx' {
					if ($rst_rx eq '') {
						$rst_rx = uc($arg);
						$rst_rx =~ s/^R//;
					}
				}
				case 'is_locator' {
					if ($locator eq '') {
						$locator = uc($arg);
						$locator =~ s/^[Ll][Oo][Cc]=//;
					}
				}
				case 'is_serial_tx' {
					if ($serial_tx eq '') {
						$serial_tx = uc($arg);
						$serial_tx =~ s/^[Tt][Xx][Ss]=//;
					}
				}
				case 'is_serial_rx' {
					if ($serial_rx eq '') {
						$serial_rx = uc($arg);
						$serial_rx =~ s/^[Rr][Xx][Ss]=//;
					}
				}
				case 'is_data_tx' {
					if ($data_tx eq '') {
						$data_tx = uc($arg);
						$data_tx =~ s/^[Tt][Xx][Dd]=//;
					}
				}
				case 'is_data_rx' {
					if ($data_rx eq '') {
						$data_rx = uc($arg);
						$data_rx =~ s/^[Rr][Xx][Dd]=//;
					}
				}
				case 'is_date' { if ($qso_date eq '') { $qso_date = $arg; } }
				case 'is_time' { if ($qso_time eq '') { $qso_time = $arg; } }
				else { $comments .= "$arg "; }
			}
		} else {
			if ($comments eq '') {
				$comments = $arg;
			} else {
				$comments .= " $arg";
			}
			$rest_is_comments = 1;
		}
	}
	# Insert default values in unset fields
	if ($freq eq '') { $mode = $config{'default_freq'}; }
	if ($mode eq '') { $mode = $config{'default_mode'}; }
	if ($rst_rx eq '') { $rst_rx = $config{'default_rst_rx'}; }
	if ($rst_tx eq '') { $rst_tx = $config{'default_rst_tx'}; }

	# Process aliases for modes
	if ($mode eq 'AMTOR') { $mode = 'TOR'; }
	if ($mode eq 'PACTOR') { $mode = 'PAC'; }
	if ($mode eq 'CLOVER') { $mode = 'CLO'; }

	# Now prepare all fields and put then in the database
	my @now = gmtime;
	if ($qso_date eq '') {
		$qso_date = sprintf('%04d-%02d-%02d', $now[5] + 1900, $now[4] + 1, $now[3]);
	}
	if ($qso_time eq '') {
		$qso_time = sprintf('%02d:%02d:00', $now[2], $now[1]);
	}
	if ( ($callsign ne '') && ($freq ne '') && ($mode ne '') ) {
		my $query = "INSERT INTO qsos (mycall, callsign, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, qso_date, qso_time, comments) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
		my $sth = $dbh->prepare($query);
		$sth->execute($config{'mycall'}, $callsign, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $qso_date, $qso_time, $comments);
		my $id = $dbh->last_insert_id(undef, undef, qw(clog id));
		list_log($dbh, \%config, $id);
	} else {
		print STDERR "ERROR: Callsign, mode and frequency are mandatory (unless set in ~/.clogrc)\n";
		exit;
	}
}

# Used to update an entry in the logbook.
sub update_entry {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $update_id = shift;
	my @args = @ARGV;
	shift(@args);
	shift(@args);
	my $callsign = '';
	my $rst_rx = '';
	my $rst_tx = '';
	my $locator = '';
	my $serial_tx = '';
	my $serial_rx = '';
	my $data_tx = '';
	my $data_rx = '';
	my $freq = '';
	my $mode = '';
	my $qso_date = '';
	my $qso_time = '';
	my $comments = '';
	my $rest_is_comments = 0;
	my $query = '';
	my $sth;
	my $dummy;

	foreach my $arg (@args) {
		my $type = get_type($arg);
		if (($rest_is_comments == 0) && ($type ne 'unknown')) {
			switch ($type) {
				case 'is_callsign' {
					$callsign = uc($arg);
					$callsign =~ s/CALL=//i;
					$query = "UPDATE qsos SET callsign=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($callsign, $update_id, $config{'mycall'});
				}
				case 'is_freq' {
					if ($freq eq '') {
						$freq = uc($arg);
						if (substr($freq, -1, 1) eq 'K') {
							$freq =~ s/K//;
							$freq = $freq / 1000;
						} else {
							$freq =~ s/M//;
						}
					}
					$query = "UPDATE qsos SET freq=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($freq, $update_id, $config{'mycall'});
				}
				case 'is_mode' {
					$mode = uc($arg);
					$query = "UPDATE qsos SET mode=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($mode, $update_id, $config{'mycall'});
				}
				case 'is_rst_tx' {
					$rst_tx = uc($arg);
					$rst_tx =~ s/^T//;
					$query = "UPDATE qsos SET rst_tx=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($rst_tx, $update_id, $config{'mycall'});
				}
				case 'is_rst_rx' {
					$rst_rx = uc($arg);
					$rst_rx =~ s/^R//;
					$query = "UPDATE qsos SET rst_rx=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($rst_rx, $update_id, $config{'mycall'});
				}
				case 'is_locator' {
					$locator = uc($arg);
					$locator =~ s/^[Ll][Oo][Cc]=//;
					$query = "UPDATE qsos SET locator=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($locator, $update_id, $config{'mycall'});
				}
				case 'is_serial_tx' {
					($dummy, $serial_tx) = split (/=/, $arg, 2);
					$query = "UPDATE qsos SET serial_tx=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($serial_tx, $update_id, $config{'mycall'});
				}
				case 'is_serial_rx' {
					($dummy, $serial_rx) = split (/=/, $arg, 2);
					$query = "UPDATE qsos SET serial_rx=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($serial_rx, $update_id, $config{'mycall'});
				}
				case 'is_data_tx' {
					($dummy, $data_tx) = split (/=/, $arg, 2);
					$query = "UPDATE qsos SET data_tx=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($data_tx, $update_id, $config{'mycall'});
				}
				case 'is_data_rx' {
					($dummy, $data_rx) = split (/=/, $arg, 2);
					$query = "UPDATE qsos SET data_rx=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($data_rx, $update_id, $config{'mycall'});
				}
				case 'is_date' {
					$qso_date = $arg;
					$query = "UPDATE qsos SET qso_date=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($qso_date, $update_id, $config{'mycall'});
				}
				case 'is_time' {
					$qso_time = $arg;
					$query = "UPDATE qsos SET qso_time=? WHERE id=? AND mycall=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($qso_time, $update_id, $config{'mycall'});
				}
				else {
					$comments .= "$arg ";
				}
			}
		} else {
			if ($comments eq '') {
				$comments = $arg;
			} else {
				$comments .= " $arg";
			}
			$rest_is_comments = 1;
		}
	}
	unless ($comments eq '') {
		$query = "UPDATE qsos SET comments=? WHERE id=? AND mycall=?;";
		$sth = $dbh->prepare($query);
		$sth->execute($comments, $update_id, $config{'mycall'});
	}
	list_log($dbh, \%config, $update_id);
}


# QSL administration
sub set_qsl {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $action = shift;
	my $qsl_id = shift;
	my $query = '';
	if ($action eq 'tx') {
		$query = "UPDATE qsos SET qsl_tx='Y' WHERE id=? AND mycall=?;";
	} else {
		$query = "UPDATE qsos SET qsl_rx='Y' WHERE id=? AND mycall=?;";
	}
	my $sth = $dbh->prepare($query);
	$sth->execute($qsl_id, $config{'mycall'});
	list_log($dbh, \%config, $qsl_id);
}

# Deletes the record with the given ID from the logbook
sub delete_entry {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $search_id = shift;
	list_log($dbh, \%config, $search_id);
	my $query = "DELETE FROM qsos WHERE id=? AND mycall=?;";
	my $sth = $dbh->prepare($query);
	$sth->execute($search_id, $config{'mycall'});
}

# Converts frequency to a hamradio band. The bands are adapted from the
# ADIF v1 specification. So if you need additional bands, don't blame me,
# but the ADIF developers ;-)
sub mhz_to_band {
	my $band = '';
	my $mhz = int(shift);
	switch ($mhz) {
		case 1                { $band = '160m'; }
		case [3,4]            { $band = '80m'; }
		case 7                { $band = '40m'; }
		case 10               { $band = '30m'; }
		case 14               { $band = '20m'; }
		case 18               { $band = '17m'; }
		case 21               { $band = '15m'; }
		case 24               { $band = '12m'; }
		case [28,29]          { $band = '10m'; }
		case [50..54]         { $band = '6m'; }
		case [144..148]       { $band = '2m'; }
		case [220..225]       { $band = '1.25m'; }
		case [420..450]       { $band = '70cm'; }
		case [902..928]       { $band = '35cm'; }
		case [1240..1300]     { $band = '23cm'; }
		case [2300..2450]     { $band = '13cm'; }
		case [3400..3410]     { $band = '9cm'; }
		case [5650..5850]     { $band = '6cm'; }
		case [10000..10500]   { $band = '3cm'; }
		case [24000..24250]   { $band = '1.25cm'; }
		case [47000..47200]   { $band = '6mm'; }
		case [75500..78000]   { $band = '4mm'; }
		case [122250..123000] { $band = '2.5mm'; }
		case [134000..136000] { $band = '2mm'; }
		case [241000..250000] { $band = '1mm'; }
		else                  { $band = ''; }
	}
	return $band;
}

# Converts band to lower and upper frequency (in MHz).
sub band_to_mhz {
	my @limits = (0, 0);
	my $band = shift;
	switch ($band) {
		case '160m'   { @limits = (     1.800,      2    ); }
		case '80m'    { @limits = (     3.500,      4    ); }
		case '40m'    { @limits = (     7    ,      7.300); }
		case '30m'    { @limits = (    10.100,     10.150); }
		case '20m'    { @limits = (    14    ,     14.350); }
		case '17m'    { @limits = (    18.068,     18.168); }
		case '15m'    { @limits = (    21    ,     21.450); }
		case '12m'    { @limits = (    24.890,     24.990); }
		case '10m'    { @limits = (    28    ,     29.700); }
		case '6m'     { @limits = (    50    ,     54    ); }
		case '2m'     { @limits = (   144    ,    148    ); }
		case '1.25m'  { @limits = (   220    ,    225    ); }
		case '70cm'   { @limits = (   420    ,    450    ); }
		case '35cm'   { @limits = (   902    ,    928    ); }
		case '23cm'   { @limits = (  1240    ,   1300    ); }
		case '13cm'   { @limits = (  2300    ,   2450    ); }
		case '9cm'    { @limits = (  3400    ,   3410    ); }
		case '6cm'    { @limits = (  5650    ,   5850    ); }
		case '3cm'    { @limits = ( 10000    ,  10500    ); }
		case '1.25cm' { @limits = ( 24000    ,  24250    ); }
		case '6mm'    { @limits = ( 47000    ,  47200    ); }
		case '4mm'    { @limits = ( 75500    ,  78000    ); }
		case '2.5mm'  { @limits = (122250    , 123000    ); }
		case '2mm'    { @limits = (134000    , 136000    ); }
		case '1mm'    { @limits = (241000    , 250000    ); }
		else          { @limits = (     0,          0    ); }
	}
	return @limits;
}

# Dumps the logbook in ADIF v1 format. Helpfull to import your logbook
# into other logbook software, a QSL-sticker tool, converter for
# contest logs, etc...
sub export_adif {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $query = '';
	my $band = '';
	my $sth;
	$query = 'SELECT id, mycall, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments FROM qsos WHERE mycall=? ORDER BY qso_date, qso_time, id;';
	$sth = $dbh->prepare($query);
	$sth->execute($config{'mycall'});
	my ($id, $mycall, $callsign, $qso_date, $qso_time, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $comments);
	$sth->bind_columns(\$id, \$mycall, \$callsign, \$qso_date, \$qso_time, \$freq, \$mode, \$rst_tx, \$rst_rx, \$locator, \$serial_tx, \$serial_rx, \$data_tx, \$data_rx, \$comments);
	print "CLog " . VERSION . " by Ernest Neijenhuis PA3HCM - ADIF v1.00 export<ADIF_VER:4>1.00<EOH>\n";
	while($sth->fetch()) {
		$qso_date =~ s/-//g;
		$qso_time =~ s/://g;
		$qso_time = substr($qso_time, 0, 4);
		$band = mhz_to_band($freq);
		$comments =~ s/[\r\n]+/ /g;
		print "<CALL:" . length($callsign) . ":C>$callsign";
		print "<OPERATOR:" . length($mycall) . ":C>$mycall";
		print "<QSO_DATE:8:D>$qso_date";
		print "<TIME_ON:4:T>$qso_time";
		print "<BAND:" . length($band) . ":C>$band";
		print "<FREQ:" . length($freq) . ":N>$freq";
		if (($mode eq 'LSB') || ($mode eq 'USB')) { $mode = 'SSB'; }
		print "<MODE:" . length($mode) . ":C>$mode";
		if ($rst_tx ne '') { print "<RST_SENT:" . length($rst_tx) . ":C>$rst_tx"; }
		if ($rst_rx ne '') { print "<RST_RCVD:" . length($rst_rx) . ":C>$rst_rx"; }
		if ($locator ne '') { print "<GRIDSQUARE:" . length($locator) . ":C>$locator"; }
		if ($serial_tx > 0) {
			print "<STX:" . length($serial_tx) . ":N>$serial_tx";
		} else {
			if ($data_tx ne '') {
				print "<STX:" . length($data_tx) . ":C>$data_tx";
			}
		}
		if ($serial_rx > 0) {
			print "<SRX:" . length($serial_rx) . ":N>$serial_rx";
		} else {
			if ($data_rx ne '') {
				print "<SRX:" . length($data_rx) . ":C>$data_rx";
			}
		}
		if ($comments ne '') { print "<COMMENT:" . length($comments) . ":C>$comments"; }
		print "<EOR>\n";
	}
}

# Dumps the logbook in Cabrillo v3 format, normally used to submit a contest log to the contest manager or log robot.
sub export_cabrillo {
	my $dbh = shift;
	my $cabrillo_version = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $query = '';
	my $sth;
	my $column = 0;
	my $band;
	$query = 'SELECT id, mycall, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments FROM qsos WHERE mycall=? ORDER BY qso_date, qso_time, id;';
	$sth = $dbh->prepare($query);
	$sth->execute($config{'mycall'});
	my ($id, $mycall, $callsign, $qso_date, $qso_time, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $comments);
	$sth->bind_columns(\$id, \$mycall, \$callsign, \$qso_date, \$qso_time, \$freq, \$mode, \$rst_tx, \$rst_rx, \$locator, \$serial_tx, \$serial_rx, \$data_tx, \$data_rx, \$comments);
	if ($cabrillo_version == 3) {
		print "START-OF-LOG: 3.0\n";
		print "CALLSIGN: " . $config{'mycall'} . "\n";
		print "CATEGORY-ASSISTED: \n";
		print "CATEGORY-BAND: \n";
		print "CATEGORY-MODE: \n";
		print "CATEGORY-OPERATOR: \n";
		print "CATEGORY-POWER: \n";
		print "CATEGORY-STATION: \n";
		print "CATEGORY-TIME: \n";
		print "CATEGORY-TRANSMITTER: \n";
		print "CATEGORY-OVERLAY: \n";
		print "CLAIMED-SCORE: \n";
		print "CLUB: \n";
		print "CONTEST: \n";
		print "CREATED-BY: CLog " . VERSION . " - Copyright (c) 2008-2015, Ernest Neijenhuis PA3HCM\n";
		print "LOCATION: \n";
		print "NAME: \n";
		print "ADDRESS: \n";
		print "ADDRESS-CITY: \n";
		print "ADDRESS-STATE-PRIVINCE: \n";
		print "ADDRESS-POSTALCODE: \n";
		print "ADDRESS-COUNTRY: \n";
		print "OPERATORS: \n";
		print "OFFTIME: \n";
		print "SOAPBOX: \n";
		print "SOAPBOX: \n";
		print "SOAPBOX: \n";
	} else {
		print "START-OF-LOG: 2.0\n";
		print "ARRL-SECTION: \n";
		print "CALLSIGN: " . $config{'mycall'} . "\n";
		print "CATEGORY-ASSISTED: \n";
		print "CATEGORY-DXPEDITION: \n";
		print "CATEGORY-OVERLAY: \n";
		print "CATEGORY-TIME: \n";
		print "CLAIMED-SCORE: \n";
		print "CLUB: \n";
		print "CONTEST: \n";
		print "CREATED-BY: CLog " . VERSION . " - Copyright (c) 2008-2015, Ernest Neijenhuis PA3HCM\n";
		print "IOTA-ISLAND-NAME: \n";
		print "NAME: \n";
		print "ADDRESS: \n";
		print "OPERATORS: \n";
		print "OFFTIME: \n";
		print "SOAPBOX: \n";
		print "SOAPBOX: \n";
		print "SOAPBOX: \n";
	}

	while($sth->fetch()) {
		$qso_time =~ s/://g;
		$qso_time = substr($qso_time, 0, 4);
		$band = mhz_to_band($freq);
		$comments =~ s/[\r\n]+/ /g;
		print "QSO:";
		foreach $column (split / /, $config{'export_cabrillo_columns'}) {
			switch ($column) {
				case 'freq' {
					switch ($band) {
						case '160m'   { print '  1800'; }
						case '80m'    { print '  3500'; }
						case '40m'    { print '  7000'; }
						case '20m'    { print ' 14000'; }
						case '15m'    { print ' 21000'; }
						case '10m'    { print ' 28000'; }
						case '6m'     { print '    50'; }
						case '2m'     { print '   144'; }
						case '70cm'   { print '   432'; }
						case '35cm'   { print '   902'; }
						case '23cm'   { print '  1.2G'; }
						case '13cm'   { print '  2.3G'; }
						case '9cm'    { print '  3.4G'; }
						case '6cm'    { print '  5.7G'; }
						case '3cm'    { print '   10G'; }
						case '1.25cm' { print '   24G'; }
						case '6mm'    { print '   47G'; }
						case '4mm'    { print '   75G'; }
						case '2.5mm'  { print '  119G'; }
						case '2mm'    { print '  142G'; }
						case '1mm'    { print '  241G'; }
						else          { print ' ?????'; }
					}
				}
				case 'mode' {
					switch ($mode) {
						case 'LSB'  { print " PH"; }
						case 'USB'  { print " PH"; }
						case 'SSB'  { print " PH"; }
						case 'AM'   { print " PH"; }
						case 'CW'   { print " CW"; }
						case 'FM'   { print " FM"; }
						case 'RTTY' { print " RY"; }
						else        { print " ??"; }
					}
				}
				case 'qso_date' {
					print " $qso_date";
				}
				case 'qso_time' {
					print " $qso_time";
				}
				case 'mycall' {
					printf (' %-13s', $mycall);
				}
				case 'callsign' {
					printf (' %-13s', $callsign);
				}
				case 'rst_rx' {
					printf (' %-3s', $rst_rx);
				}
				case 'rst_tx' {
					printf (' %-3s', $rst_tx);
				}
				case 'data_rx' {
					printf (' %-6s', $data_rx);
				}
				case 'data_tx' {
					printf (' %-6s', $data_tx);
				}
				case 'serial_rx' {
					printf (' %-4s', $serial_rx);
				}
				case 'serial_tx' {
					printf (' %-4s', $serial_tx);
				}
				case 'mylocator' {
					printf (' %-6s', $config{'mylocator'});
				}
				case 'mygrid' {
					printf (' %-4s', substr($config{'mylocator'}, 0, 4));
				}
				case 'locator' {
					printf (' %-6s', $locator);
				}
				case 'grid' {
					printf (' %-4s', substr($locator, 0, 4));
				}
			}
		}
		print "\n";
	}
	print "END-OF-LOG: \n";
}

# Dumps the logbook in a HTML table. Helpfull to import your logbook into your website.
sub export_html {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $query = '';
	my $band = '';
	my $distance;
	my $bearing;
	my $column = 0;
	my $sth;
	$query = 'SELECT id, mycall, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments, qsl_tx, qsl_rx FROM qsos WHERE mycall=? ORDER BY qso_date DESC, qso_time DESC, id;';
	$sth = $dbh->prepare($query);
	$sth->execute($config{'mycall'});
	my ($id, $mycall, $callsign, $qso_date, $qso_time, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $comments, $qsl_tx, $qsl_rx);
	$sth->bind_columns(\$id, \$mycall, \$callsign, \$qso_date, \$qso_time, \$freq, \$mode, \$rst_tx, \$rst_rx, \$locator, \$serial_tx, \$serial_rx, \$data_tx, \$data_rx, \$comments, \$qsl_tx, \$qsl_rx);
	print "<table>\n";
	print "<tr>";
	foreach $column (split / /, $config{'export_html_columns'}) {
		switch ($column) {
			case 'mycall' {
				print "<th>Operator</th>";
			}
			case 'callsign' {
				print "<th>Callsign</th>";
			}
			case 'qso_date' {
				print "<th>Date</th>";
			}
			case 'qso_time' {
				print "<th>UTC</th>";
			}
			case 'band' {
				print "<th>Band</th>";
			}
			case 'freq' {
				print "<th>MHz</th>";
			}
			case 'mode' {
				print "<th>Mode</th>";
			}
			case 'rst_tx' {
				print "<th>RST Sent</th>";
			}
			case 'rst_rx' {
				print "<th>RST Rcvd</th>";
			}
			case 'locator' {
				print "<th>Locator</th>";
			}
			case 'distance' {
				print "<th>KM</th>";
			}
			case 'bearing' {
				print "<th>Deg</th>";
			}
			case 'serial_tx' {
				print "<th>TX#</th>";
			}
			case 'serial_rx' {
				print "<th>RX#</th>";
			}
			case 'data_tx' {
				print "<th>TXd</th>";
			}
			case 'data_rx' {
				print "<th>RXd</th>";
			}
			case 'comments' {
				print "<th>Comments</th>";
			}
			case 'dxcc' {
				print "<th>DXCC</th>";
			}
			case 'qsl' {
				print "<th>QSL Sent/Rcvd</th>";
			}
		}
	}
	print "</tr>\n";
	while($sth->fetch()) {
		$qso_time = substr($qso_time, 0, 5);
		$band = mhz_to_band($freq);
		$comments =~ s/[\r\n]+/ /g;
		print "<tr>";
		foreach $column (split / /, $config{'export_html_columns'}) {
			switch ($column) {
				case 'mycall' {
					print "<td>$mycall</td>";
				}
				case 'callsign' {
					print "<td>$callsign</td>";
				}
				case 'qso_date' {
					print "<td>$qso_date</td>";
				}
				case 'qso_time' {
					print "<td>$qso_time</td>";
				}
				case 'band' {
					print "<td>$band</td>";
				}
				case 'freq' {
					print "<td>$freq</td>";
				}
				case 'mode' {
					print "<td>$mode</td>";
				}
				case 'rst_tx' {
					print "<td>$rst_tx</td>";
				}
				case 'rst_rx' {
					print "<td>$rst_rx</td>";
				}
				case 'locator' {
					print "<td>$locator</td>";
				}
				case 'bearing' {
					if (($locator ne '') && ($config{'mylocator'} ne '')) {
						($bearing, $distance) = beardist(qratoll($config{'mylocator'}), qratoll($locator));
						print "<td>$bearing</td>";
					} else {
						print "<td></td>";
					}
				}
				case 'distance' {
					if (($locator ne '') && ($config{'mylocator'} ne '')) {
						($bearing, $distance) = beardist(qratoll($config{'mylocator'}), qratoll($locator));
						print "<td>$distance</td>";
					} else {
						print "<td></td>";
					}
				}
				case 'serial_tx' {
					print "<td>$serial_tx</td>";
				}
				case 'serial_rx' {
					print "<td>$serial_rx</td>";
				}
				case 'data_tx' {
					print "<td>$data_tx</td>";
				}
				case 'data_rx' {
					print "<td>$data_rx</td>";
				}
				case 'comments' {
					print "<td>$comments</td>";
				}
				case 'dxcc' {
					print "<td>" . callsign_to_dxcc($dbh, $callsign) . "</td>";
				}
				case 'qsl' {
					print "<td>";
					if ($qsl_tx eq 'Y') {
						print "S/";
					} else {
						print "-/";
					}
					if ($qsl_rx eq 'Y') {
						print "R";
					} else {
						print "-";
					}
					print "</td>";
				}
			}
		}
		print "</tr>\n";
	}
	print "</table>\n";
}

# Dumps the logbook in CSV format. Helpfull to import your logbook
# into a spreadsheet, database, etc.
sub export_csv {
	my $dbh = shift;
	my $config_ref = shift;
	my %config = %{$config_ref};
	my $query = '';
	my $band = '';
	my $sth;
	$query = 'SELECT id, callsign, qso_date, qso_time, freq, mode, rst_tx, rst_rx, locator, serial_tx, serial_rx, data_tx, data_rx, comments FROM qsos WHERE mycall=? ORDER BY qso_date, qso_time, id;';
	$sth = $dbh->prepare($query);
	$sth->execute($config{'mycall'});
	my ($id, $callsign, $qso_date, $qso_time, $freq, $mode, $rst_tx, $rst_rx, $locator, $serial_tx, $serial_rx, $data_tx, $data_rx, $comments);
	$sth->bind_columns(\$id, \$callsign, \$qso_date, \$qso_time, \$freq, \$mode, \$rst_tx, \$rst_rx, \$locator, \$serial_tx, \$serial_rx, \$data_tx, \$data_rx, \$comments);
	print '"ID","CALLSIGN","QSO_DATE","QSO_TIME","BAND","FREQ","MODE","RST_TX","RST_RX","LOCATOR","SERIAL_TX","SERIAL_RX","DATA_TX","DATA_RX","COMMENTS"' . "\n";
	while($sth->fetch()) {
		$band = mhz_to_band($freq);
		$comments =~ s/[\r\n]+/ /g;
		print '"' . $id . '",';
		print '"' . $callsign . '",';
		print '"' . $qso_date . '",';
		print '"' . $qso_time . '",';
		print '"' . $band . '",';
		print '"' . $freq . '",';
		print '"' . $mode . '",';
		print '"' . $rst_tx . '",';
		print '"' . $rst_rx . '",';
		print '"' . $locator . '",';
		print '"' . $serial_tx . '",';
		print '"' . $serial_rx . '",';
		print '"' . $data_tx . '",';
		print '"' . $data_rx . '",';
		print '"' . $comments . '"';
		print "\n";
	}
}



sub import_cty {
	my $dbh = shift;
	my $cty_dat_file = shift;
	my $country = '';
	my $cqzone = '';
	my $ituzone = '';
	my $continent = '';
	my $latitude = '';
	my $longitude = '';
	my $gmt_offset = 0;
	my $dxcc = '';
	my @prefix = ();
	my $i = 0;
	my $german_dxcc = 0;
	my $prefix = '';
	my $query = '';
	my $sth;
	my $found_dxcc = '';
	
	if (-r $cty_dat_file) {
		print "Importing $cty_dat_file...\n";
		open (PREFIX, "<$cty_dat_file");
		$query = "DELETE FROM dxccs;";
		$sth = $dbh->prepare($query);
		$sth->execute();
		$query = "DELETE FROM prefixes;";
		$sth = $dbh->prepare($query);
		$sth->execute();
		while (<PREFIX>) {
			chomp;
			unless (substr($_, 1, 1) eq ' ') {
				# This is a new country definition
				$country = substr ($_, 0, 26); $country =~ s/:\s*$//;
				$cqzone = substr ($_, 26, 5); $cqzone =~ s/:\s*$//;
				$ituzone = substr ($_, 31, 5); $ituzone =~ s/:\s*$//;
				$continent = substr ($_, 36, 5); $continent =~ s/:\s*$//;
				$latitude = substr ($_, 41, 9); $latitude =~ s/:\s*$//;
				$longitude = substr ($_, 50, 10); $longitude =~ s/:\s*$//;
				$gmt_offset = substr ($_, 60, 9); $gmt_offset =~ s/:\s*$//;
				$dxcc = substr ($_, 69, 6); $dxcc =~ s/:\s*$//;
				if (substr($dxcc, 0, 1) eq '*') {
					$german_dxcc = 1;
					$dxcc =~ s/^\*//;
				} else {
					$german_dxcc = 0;
				}
				$query = "INSERT INTO dxccs (country, cqzone, ituzone, continent, latitude, longitude, gmt_offset, dxcc, german_dxcc) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);";
				$sth = $dbh->prepare($query);
				$sth->execute($country, $cqzone, $ituzone, $continent, $latitude, $longitude, $gmt_offset, $dxcc, $german_dxcc);
			} else {
				s/\s+//g;
				s/;$//;
				@prefix = split /,/;
				for ($i=0; $i<@prefix;$i++) {
					$prefix[$i] =~ s/\(.+\)//;
					$prefix[$i] =~ s/\[.+\]//;
					$prefix[$i] =~ s/^=//;
					$prefix[$i] =~ s/\;//;
					$query = "SELECT dxcc AS found_dxcc FROM prefixes WHERE prefix=?;";
					$sth = $dbh->prepare($query);
					$sth->execute($prefix[$i]);
					if ($sth->rows == 0) {
						$query = "INSERT INTO prefixes (dxcc, prefix) VALUES (?, ?);";
						$sth = $dbh->prepare($query);
						$sth->execute($dxcc, $prefix[$i]);
						
					} else {
						($found_dxcc) = $sth->fetchrow_array;
						if (length($dxcc) < length($found_dxcc)) {
							print STDERR "WARNING: Multiple DXCC's found for call/prefix " . $prefix[$i] . ", using $dxcc instead of $found_dxcc.\n";
							$query = "DELETE FROM prefixes WHERE dxcc=? AND prefix=?;";
							$sth = $dbh->prepare($query);
							$sth->execute($found_dxcc, $prefix[$i]);
							$query = "INSERT INTO prefixes (dxcc, prefix) VALUES (?, ?);";
							$sth = $dbh->prepare($query);
							$sth->execute($dxcc, $prefix[$i]);
						} else {
							print STDERR "WARNING: Multiple DXCC's found for call/prefix " . $prefix[$i] . ", using $found_dxcc instead of $dxcc.\n";
						}
					}
				}
			}
		}
		close PREFIX;
		$query = "SELECT dxcc FROM dxccs;";
		$sth = $dbh->prepare($query);
		$sth->execute();
		print "Finished importing $cty_dat_file, loaded " . $sth->rows . " DXCC's and ";
		$query = "SELECT prefix FROM prefixes;";
		$sth = $dbh->prepare($query);
		$sth->execute();
		print $sth->rows . " prefixes.\n";
	} else {
		print STDERR "ERROR: unable to read file: $cty_dat_file\n";
	}
}

sub callsign_to_dxcc {
	my $dbh = shift;
	my $callsign = shift;
	my $i;
	my $found = 0;
	my $query = '';
	my $dxcc = '';
	my $sth;
	my $callsign_size = length($callsign);
	for ($i=$callsign_size; $i>=1; $i--) {
		$callsign = substr($callsign, 0, $i);
		$query = "SELECT dxcc FROM prefixes WHERE prefix=?;";
		$sth = $dbh->prepare($query);
		$sth->execute($callsign);
		if ($sth->rows == 1) {
			$found = 1;
			($dxcc) = $sth->fetchrow;
			last;
		}
	}
	if ($found == 1) {
		return $dxcc;
	} else {
		return '';
	}
}

sub dxcc_to_country {
	my $dbh = shift;
	my $dxcc = shift;
	my $i;
	my $country = '';
	my $query = "SELECT country FROM dxccs WHERE dxcc=?;";
	my $sth = $dbh->prepare($query);
	$sth->execute($dxcc);
	if ($sth->rows >= 1) {
		($country) = $sth->fetchrow;
		return $country;
	} else {
		return '';
	}
}

sub statistics {
	my $dbh = shift;
	my $config_ref = shift;
        my %config = %{$config_ref};
	my %qsos = ();
	my %dxccs = ();
	my $dxcc = '';
	my $band = '';
	my $callsign = '';
	my $freq = '';
	my $mode = '';
	$config{'statistics_modes'} =~ s/\s+//g;
	my @modes = split /,/, uc($config{'statistics_modes'});
	$config{'statistics_bands'} =~ s/\s+//g;
	my @bands = split /,/, lc($config{'statistics_bands'});
	my $query = "SELECT callsign, freq, mode FROM qsos WHERE mycall=?;";
	my $sth = $dbh->prepare($query);
	$sth->execute($config{'mycall'});
	print $sth->rows . " QSO's logged (on all bands)\n";
	$sth->bind_columns(\$callsign, \$freq, \$mode);
	while($sth->fetch()) {
		$band = mhz_to_band($freq);
		if (exists $qsos{$band}{$mode}) {;
			$qsos{$band}{$mode}++;
		} else {
			$qsos{$band}{$mode} = 1;
		}
		if (exists $qsos{$band}{'ALL'}) {;
			$qsos{$band}{'ALL'}++;
		} else {
			$qsos{$band}{'ALL'} = 1;
		}
		if (($mode eq 'LSB') or ($mode eq 'USB')) {
			if (exists $qsos{$band}{'SSB'}) {;
				$qsos{$band}{'SSB'}++;
			} else {
				$qsos{$band}{'SSB'} = 1;
			}
		}
		$dxcc = callsign_to_dxcc ($dbh, $callsign);
		if (exists $qsos{$band}{'dxccs'}{$dxcc}) {
			$qsos{$band}{'dxccs'}{$dxcc}++;
		} else {
			$qsos{$band}{'dxccs'}{$dxcc} = 1;
		}
		if (exists $dxccs{$dxcc}) {
			$dxccs{$dxcc}++;
		} else {
			$dxccs{$dxcc} = 1;
		}
	}
	print "\n";
	print "QSO's per mode/band:\n";
	print "MODE ";
	foreach $band (@bands) {
		printf ('%5s ', $band);
	}
	print "\n";
	foreach $mode (@modes) {
		printf ('%-4s ', $mode);
		foreach $band (@bands) {
			if (exists ($qsos{$band}{$mode})) {
				printf ('%5d ', $qsos{$band}{$mode});
			} else {
				print '    - ';
			}
		}
		print "\n";
	}
	print "\n";

	print "DXCC per band:\n";
	print "DXCC ";
	foreach $band (@bands) {
		printf ('%5s ', $band);
	}
	print "\n";
	foreach $dxcc (sort keys %dxccs) {
		printf('%-4s ', $dxcc);
		foreach $band (@bands) {
			if (exists $qsos{$band}{'dxccs'}{$dxcc}) {
				printf ('%5s ', $qsos{$band}{'dxccs'}{$dxcc});
			} else {
				print "    - ";
			}
		}
		print "\n";
	}
	print "\n";
	print "DXCC summary:\n";
	print "DXCC ";
	foreach $band (@bands) {
		printf ('%5s ', $band);
	}
	print "\n";
	print "     ";
	foreach $band (@bands) {
		if (exists ($qsos{$band}{'dxccs'})) {
			my $dxcccount = 0;
			foreach $dxcc (keys %{ $qsos{$band}{'dxccs'} }) {
				$dxcccount++;
			}
			printf ('%5s ', $dxcccount);
		} else {
			print "    - ";
		}
	}
	print "\n";
	print "\n";
}

sub dbupgrade {
	my $dbh = shift;
	my $config_ref = shift;
        my %config = %{$config_ref};
	my $query = "SELECT setting_value FROM settings WHERE setting_name='clog_database_version';";
	my $sth = $dbh->prepare($query);
	$sth->execute();
	my ($clog_database_version) = $sth->fetchrow_array;
	switch ($clog_database_version) {
		case '0.5b' {
			print "Upgrading from $clog_database_version to " . DBVERSION . "...\n";
			$dbh->do("ALTER TABLE qsos ADD mycall    VARCHAR(12) NOT NULL AFTER id;")            || die "ERROR: upgrade failed! See the README file for tips on how to solve this.\n";
			$dbh->do("ALTER TABLE qsos ADD locator   VARCHAR(12) NOT NULL AFTER rst_rx;")        || die "ERROR: upgrade failed! See the README file for tips on how to solve this.\n";
			$dbh->do("ALTER TABLE qsos ADD serial_tx INT NOT NULL DEFAULT '0' AFTER locator;")   || die "ERROR: upgrade failed! See the README file for tips on how to solve this.\n";
			$dbh->do("ALTER TABLE qsos ADD serial_rx INT NOT NULL DEFAULT '0' AFTER serial_tx;") || die "ERROR: upgrade failed! See the README file for tips on how to solve this.\n";
			$dbh->do("ALTER TABLE qsos ADD data_tx   VARCHAR(12) NOT NULL AFTER serial_rx;")     || die "ERROR: upgrade failed! See the README file for tips on how to solve this.\n";
			$dbh->do("ALTER TABLE qsos ADD data_rx   VARCHAR(12) NOT NULL AFTER data_tx;")       || die "ERROR: upgrade failed! See the README file for tips on how to solve this.\n";
			$dbh->do("UPDATE qsos SET mycall=' " . $config{'mycall'} . "' WHERE mycall='';")     || die "ERROR: upgrade failed!\n";
			$dbh->do("UPDATE settings SET setting_value='0.6b' WHERE setting_name='clog_database_version';") || die "ERROR: upgrade failed!\n";
			print "Upgrade was successfull.\n";
			print "Now run 'clog dbupgrade' again to upgrade to version 0.6b!\n";
		}
		case '0.6b' {
			print "Upgrading from $clog_database_version to 0.8b...\n";
			$dbh->do("UPDATE settings SET setting_value='0.8b' WHERE setting_name='clog_database_version';") || die "ERROR: upgrade failed!\n";
			print "Upgrade was successfull.\n";
			print "Now run 'clog dbupgrade' again to upgrade to version 0.9b!\n";
		}
		case '0.8b' {
			print "Upgrading from $clog_database_version to 0.9b...\n";
			$dbh->do("UPDATE settings SET setting_value='0.9b' WHERE setting_name='clog_database_version';") || die "ERROR: upgrade failed!\n";
			$dbh->do("ALTER TABLE qsos MODIFY mycall VARCHAR(32);") || die "ERROR: upgrade failed!\n";
			$dbh->do("ALTER TABLE qsos MODIFY callsign VARCHAR(32);") || die "ERROR: upgrade failed!\n";
			print "Upgrade was successfull.\n";
			print "Now run 'clog dbupgrade' again to upgrade to version 1.0!\n";
		}
		case '0.9b' {
			print "Upgrading from $clog_database_version to 1.0...\n";
			$dbh->do("UPDATE settings SET setting_value='1.0' WHERE setting_name='clog_database_version';") || die "ERROR: upgrade failed!\n";
			print "Upgrade was successfull.\n";
		}
		case '1.0' {
			print "Upgrading from $clog_database_version to 1.1...\n";
			$dbh->do("UPDATE settings SET setting_value='1.1' WHERE setting_name='clog_database_version';") || die "ERROR: upgrade failed!\n";
			print "Upgrade was successfull.\n";
		}
		case '1.1' {
			print "Nothing to do...\n";
		}
		default {
			print STDERR "ERROR: Unable to determine current database version.\n";
		}
	}
}

# degrees to radians
sub deg2rad {
	my $n = shift;
	return (($n / 180) * PI);
}

# radians to degrees
sub rad2deg {
        my $n = shift;
        return ($n / PI) * 180;
}

# Calculates bearing and distance between two locations
sub beardist {
	my $hn = deg2rad(shift);
	my $he = deg2rad(shift);
	my $n = deg2rad(shift);
	my $e = deg2rad(shift);
	return (0, 0) if $hn == $n && $he == $e;
	my $co = cos($he-$e)*cos($hn)*cos($n)+sin($hn)*sin($n);
	my $ca = $co ? atan(abs(sqrt(1-$co*$co)/$co)) : PI;
	$ca = PI - $ca if $co < 0;
	my $dx = 6367*$ca;
	my $si = sin($e-$he)*cos($n)*cos($hn);
	$co = sin($n)-sin($hn)*cos($ca);
	my $az = $co ? atan(abs($si/$co)) : PI;
	$az = PI - $az if $co < 0;
	$az = -$az if $si < 0;
	$az = $az+2 * PI if $az < 0;
	return (rad2deg($az), $dx);
}

# Converts QRA-locator to longitude/latitude
sub qratoll {
	my $qra = uc shift;
	my ($p1, $p2, $p3, $p4, $p5, $p6) = unpack 'AAAAAA', $qra;
	($p1, $p2, $p3, $p4, $p5, $p6) = (ord($p1)-ord('A'), ord($p2)-ord('A'), ord($p3)-ord('0'), ord($p4)-ord('0'), ord($p5)-ord('A'), ord($p6)-ord('A') );
	my $long = ($p1*20) + ($p3*2) + (($p5+0.5)/12) - 180;
	my $lat = ($p2*10) + $p4 + (($p6+0.5)/24) - 90;
	return ($lat, $long);
}


# -------------------------------------------------------------------------
# MAIN ROUTINE STARTS HERE
# -------------------------------------------------------------------------

# No arguments? Show the help page!
if (@ARGV == 0) {
	syntax();
	exit 1;
}

# Read the configfile and update the settings in %config.
%config = read_configfile(\%config);
if ($config{'mycall'} eq '') {
	die "ERROR: You must configure 'mycall' in your ~/.clogrc file.\n";
}

# Connect to the database
my $dbh = DBI->connect("dbi:mysql:$config{'dbname'};$config{'dbhost'}", $config{'dbuser'}, $config{'dbpass'});

# Verify CLog database version
if ($ARGV[0] ne 'dbupgrade') {
	my $query = "SELECT setting_value FROM settings WHERE setting_name='clog_database_version';";
	my $sth = $dbh->prepare($query);
	$sth->execute();
	my ($clog_database_version) = $sth->fetchrow_array;
	if ($clog_database_version ne DBVERSION) {
		die "ERROR: wrong database version: found $clog_database_version, expected version " . DBVERSION . ".\nPlease read the README file for upgrade instructions.\n";
	}
}

# Parse the command-line
switch ($ARGV[0]) {
	case /^ad.*/ { # add
		add_entry ($dbh, \%config);
	}
	case /^up.*/ { # update
		if (exists ($ARGV[1])) {
			my $update_id = int($ARGV[1]);
			if ($update_id > 0) {
				update_entry($dbh, \%config, $update_id);
			} else {
				syntax();
			}
		} else {
			syntax();
		}
	}
	case /^de.*/ { # delete
		if (exists ($ARGV[1])) {
			my $delete_id = int($ARGV[1]);
			if ($delete_id > 0) {
				delete_entry($dbh, \%config, $delete_id);
			} else {
				syntax();
			}
		} else {
			syntax();
		}
	}
	case /^li.*/ { # list
		if (exists ($ARGV[1])) {
			my $list_id = int($ARGV[1]);
			if ($list_id > 0) {
				list_log($dbh, \%config, $list_id);
			} else {
				syntax();
			}
		} else {
			list_log($dbh, \%config, 0);
		}
	}
	case /^lo.*/ { # locator
		if (exists ($ARGV[1])) {
			my $locator = $ARGV[1];
			my ($bearing, $distance) = beardist(qratoll($config{'mylocator'}), qratoll($locator));
			$distance = int($distance);
			$bearing = int($bearing);
			print uc($locator) . ": $distance km, $bearing degrees\n";
		} else {
			syntax();
		}
	}
	case /^sh.*/ { # show
		if (exists ($ARGV[1])) {
			my $show_id = int($ARGV[1]);
			if ($show_id > 0) {
				show_entry($dbh, \%config, $show_id);
			} else {
				syntax();
			}
		} else {
			syntax();
		}
	}
	case 'export_adif' {
		export_adif ($dbh, \%config);
	}
	case 'export_cab2' {
		export_cabrillo ($dbh, 2, \%config);
	}
	case 'export_cab3' {
		export_cabrillo ($dbh, 3, \%config);
	}
	case 'export_csv' {
		export_csv ($dbh, \%config);
	}
	case 'export_html' {
		export_html ($dbh, \%config);
	}
	case 'import_cty' {
		if (exists ($ARGV[1])) {
			import_cty($dbh, $ARGV[1]);
		} else {
			syntax();
		}
	}
	case /^dx.*/ { # dxcc
		if (exists ($ARGV[1])) {
			my $dxcc = callsign_to_dxcc($dbh, uc($ARGV[1]));
			unless ($dxcc eq '') {
				print "DXCC: $dxcc (" . dxcc_to_country($dbh, $dxcc) . ")\n";
			} else {
				print "DXCC: unknown prefix, did you import the latest cty.dat?\n";
			}
		} else {
			syntax();
		}
	}
	case /^qs.*/ {
		switch ($ARGV[1]) {
			case 'tx' {
				if (exists ($ARGV[2])) {
					my $qsl_id = int($ARGV[2]);
					set_qsl($dbh, \%config, 'tx', $qsl_id);
				} else {
					syntax();
				}
			}
			case 'rx' {
				if (exists ($ARGV[2])) {
					my $qsl_id = int($ARGV[2]);
					set_qsl($dbh, \%config, 'rx', $qsl_id);
				} else {
					syntax();
				}
			}
			else {
				syntax();
			}
		}
	}
	case /^st.*/ { # statistics
		statistics($dbh, \%config);
	}
	case 'dbupgrade' {
		dbupgrade($dbh, \%config);
	}
	else {
		syntax();
	}
}
#$sth->finish;
$dbh->disconnect;
